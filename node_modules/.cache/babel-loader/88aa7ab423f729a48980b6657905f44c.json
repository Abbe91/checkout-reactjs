{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport React from 'react';\nimport classNames from 'classnames';\nimport shallowEqual from 'shallowequal';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\n\nvar _trimAlignValue = function trimAlignValue(_ref) {\n  var value = _ref.value,\n      handle = _ref.handle,\n      bounds = _ref.bounds,\n      props = _ref.props;\n  var allowCross = props.allowCross,\n      pushable = props.pushable;\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\n\nvar Range =\n/** @class */\nfunction () {\n  var Range = /*#__PURE__*/function (_React$Component) {\n    _inherits(Range, _React$Component);\n\n    var _super = _createSuper(Range);\n\n    function Range(props) {\n      var _this;\n\n      _classCallCheck(this, Range);\n\n      _this = _super.call(this, props);\n\n      _this.onEnd = function (force) {\n        var handle = _this.state.handle;\n\n        _this.removeDocumentEvents();\n\n        if (handle !== null || force) {\n          _this.props.onAfterChange(_this.getValue());\n        }\n\n        _this.setState({\n          handle: null\n        });\n      };\n\n      var count = props.count,\n          min = props.min,\n          max = props.max;\n      var initialValue = Array.apply(void 0, _toConsumableArray(Array(count + 1))).map(function () {\n        return min;\n      });\n      var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;\n      var value = props.value !== undefined ? props.value : defaultValue;\n      var bounds = value.map(function (v, i) {\n        return _trimAlignValue({\n          value: v,\n          handle: i,\n          props: props\n        });\n      });\n      var recent = bounds[0] === max ? 0 : bounds.length - 1;\n      _this.state = {\n        handle: null,\n        recent: recent,\n        bounds: bounds\n      };\n      return _this;\n    }\n    /**\n     * [Legacy] Used for inherit other component.\n     * It's a bad code style which should be refactor.\n     */\n\n    /* eslint-disable @typescript-eslint/no-unused-vars, class-methods-use-this */\n\n\n    _createClass(Range, [{\n      key: \"calcValueByPos\",\n      value: function calcValueByPos(value) {\n        return 0;\n      }\n    }, {\n      key: \"calcOffset\",\n      value: function calcOffset(value) {\n        return 0;\n      }\n    }, {\n      key: \"saveHandle\",\n      value: function saveHandle(index, h) {}\n    }, {\n      key: \"removeDocumentEvents\",\n      value: function removeDocumentEvents() {}\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps, prevState) {\n        var _this2 = this;\n\n        if (!('value' in this.props || 'min' in this.props || 'max' in this.props)) {\n          return;\n        }\n\n        if (this.props.min === prevProps.min && this.props.max === prevProps.max && shallowEqual(this.props.value, prevProps.value)) {\n          return;\n        }\n\n        var _this$props = this.props,\n            onChange = _this$props.onChange,\n            value = _this$props.value;\n        var currentValue = value || prevState.bounds;\n\n        if (currentValue.some(function (v) {\n          return utils.isValueOutOfRange(v, _this2.props);\n        })) {\n          var newValues = currentValue.map(function (v) {\n            return utils.ensureValueInRange(v, _this2.props);\n          });\n          onChange(newValues);\n        }\n      }\n    }, {\n      key: \"onChange\",\n      value: function onChange(state) {\n        var props = this.props;\n        var isNotControlled = !('value' in props);\n\n        if (isNotControlled) {\n          this.setState(state);\n        } else {\n          var controlledState = {};\n          ['handle', 'recent'].forEach(function (item) {\n            if (state[item] !== undefined) {\n              controlledState[item] = state[item];\n            }\n          });\n\n          if (Object.keys(controlledState).length) {\n            this.setState(controlledState);\n          }\n        }\n\n        var data = _objectSpread(_objectSpread({}, this.state), state);\n\n        var changedValue = data.bounds;\n        props.onChange(changedValue);\n      }\n    }, {\n      key: \"onStart\",\n      value: function onStart(position) {\n        var props = this.props,\n            state = this.state;\n        var bounds = this.getValue();\n        props.onBeforeChange(bounds);\n        var value = this.calcValueByPos(position);\n        this.startValue = value;\n        this.startPosition = position;\n        var closestBound = this.getClosestBound(value);\n        this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n        this.setState({\n          handle: this.prevMovedHandleIndex,\n          recent: this.prevMovedHandleIndex\n        });\n        var prevValue = bounds[this.prevMovedHandleIndex];\n        if (value === prevValue) return;\n\n        var nextBounds = _toConsumableArray(state.bounds);\n\n        nextBounds[this.prevMovedHandleIndex] = value;\n        this.onChange({\n          bounds: nextBounds\n        });\n      }\n    }, {\n      key: \"onMove\",\n      value: function onMove(e, position) {\n        utils.pauseEvent(e);\n        var state = this.state;\n        var value = this.calcValueByPos(position);\n        var oldValue = state.bounds[state.handle];\n        if (value === oldValue) return;\n        this.moveTo(value);\n      }\n    }, {\n      key: \"onKeyboard\",\n      value: function onKeyboard(e) {\n        var _this$props2 = this.props,\n            reverse = _this$props2.reverse,\n            vertical = _this$props2.vertical;\n        var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n\n        if (valueMutator) {\n          utils.pauseEvent(e);\n          var state = this.state,\n              props = this.props;\n          var bounds = state.bounds,\n              handle = state.handle;\n          var oldValue = bounds[handle === null ? state.recent : handle];\n          var mutatedValue = valueMutator(oldValue, props);\n\n          var value = _trimAlignValue({\n            value: mutatedValue,\n            handle: handle,\n            bounds: state.bounds,\n            props: props\n          });\n\n          if (value === oldValue) return;\n          var isFromKeyboardEvent = true;\n          this.moveTo(value, isFromKeyboardEvent);\n        }\n      }\n    }, {\n      key: \"getValue\",\n      value: function getValue() {\n        return this.state.bounds;\n      }\n    }, {\n      key: \"getClosestBound\",\n      value: function getClosestBound(value) {\n        var bounds = this.state.bounds;\n        var closestBound = 0;\n\n        for (var i = 1; i < bounds.length - 1; i += 1) {\n          if (value >= bounds[i]) {\n            closestBound = i;\n          }\n        }\n\n        if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n          closestBound += 1;\n        }\n\n        return closestBound;\n      }\n    }, {\n      key: \"getBoundNeedMoving\",\n      value: function getBoundNeedMoving(value, closestBound) {\n        var _this$state = this.state,\n            bounds = _this$state.bounds,\n            recent = _this$state.recent;\n        var boundNeedMoving = closestBound;\n        var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n\n        if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n          boundNeedMoving = recent;\n        }\n\n        if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n          boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n        }\n\n        return boundNeedMoving;\n      }\n    }, {\n      key: \"getLowerBound\",\n      value: function getLowerBound() {\n        return this.state.bounds[0];\n      }\n    }, {\n      key: \"getUpperBound\",\n      value: function getUpperBound() {\n        var bounds = this.state.bounds;\n        return bounds[bounds.length - 1];\n      }\n      /**\n       * Returns an array of possible slider points, taking into account both\n       * `marks` and `step`. The result is cached.\n       */\n\n    }, {\n      key: \"getPoints\",\n      value: function getPoints() {\n        var _this$props3 = this.props,\n            marks = _this$props3.marks,\n            step = _this$props3.step,\n            min = _this$props3.min,\n            max = _this$props3.max;\n        var cache = this.internalPointsCache;\n\n        if (!cache || cache.marks !== marks || cache.step !== step) {\n          var pointsObject = _objectSpread({}, marks);\n\n          if (step !== null) {\n            for (var point = min; point <= max; point += step) {\n              pointsObject[point] = point;\n            }\n          }\n\n          var points = Object.keys(pointsObject).map(parseFloat);\n          points.sort(function (a, b) {\n            return a - b;\n          });\n          this.internalPointsCache = {\n            marks: marks,\n            step: step,\n            points: points\n          };\n        }\n\n        return this.internalPointsCache.points;\n      }\n    }, {\n      key: \"moveTo\",\n      value: function moveTo(value, isFromKeyboardEvent) {\n        var _this3 = this;\n\n        var state = this.state,\n            props = this.props;\n\n        var nextBounds = _toConsumableArray(state.bounds);\n\n        var handle = state.handle === null ? state.recent : state.handle;\n        nextBounds[handle] = value;\n        var nextHandle = handle;\n\n        if (props.pushable !== false) {\n          this.pushSurroundingHandles(nextBounds, nextHandle);\n        } else if (props.allowCross) {\n          nextBounds.sort(function (a, b) {\n            return a - b;\n          });\n          nextHandle = nextBounds.indexOf(value);\n        }\n\n        this.onChange({\n          recent: nextHandle,\n          handle: nextHandle,\n          bounds: nextBounds\n        });\n\n        if (isFromKeyboardEvent) {\n          // known problem: because setState is async,\n          // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n          // cause onBeforeChange and onAfterChange receive wrong value.\n          // here use setState callback to hack，but not elegant\n          this.props.onAfterChange(nextBounds);\n          this.setState({}, function () {\n            _this3.handlesRefs[nextHandle].focus();\n          });\n          this.onEnd();\n        }\n      }\n    }, {\n      key: \"pushSurroundingHandles\",\n      value: function pushSurroundingHandles(bounds, handle) {\n        var value = bounds[handle];\n        var pushable = this.props.pushable;\n        var threshold = Number(pushable);\n        var direction = 0;\n\n        if (bounds[handle + 1] - value < threshold) {\n          direction = +1; // push to right\n        }\n\n        if (value - bounds[handle - 1] < threshold) {\n          direction = -1; // push to left\n        }\n\n        if (direction === 0) {\n          return;\n        }\n\n        var nextHandle = handle + direction;\n        var diffToNext = direction * (bounds[nextHandle] - value);\n\n        if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n          // revert to original value if pushing is impossible\n          // eslint-disable-next-line no-param-reassign\n          bounds[handle] = bounds[nextHandle] - direction * threshold;\n        }\n      }\n    }, {\n      key: \"pushHandle\",\n      value: function pushHandle(bounds, handle, direction, amount) {\n        var originalValue = bounds[handle];\n        var currentValue = bounds[handle];\n\n        while (direction * (currentValue - originalValue) < amount) {\n          if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n            // can't push handle enough to create the needed `amount` gap, so we\n            // revert its position to the original value\n            // eslint-disable-next-line no-param-reassign\n            bounds[handle] = originalValue;\n            return false;\n          }\n\n          currentValue = bounds[handle];\n        } // the handle was pushed enough to create the needed `amount` gap\n\n\n        return true;\n      }\n    }, {\n      key: \"pushHandleOnePoint\",\n      value: function pushHandleOnePoint(bounds, handle, direction) {\n        var points = this.getPoints();\n        var pointIndex = points.indexOf(bounds[handle]);\n        var nextPointIndex = pointIndex + direction;\n\n        if (nextPointIndex >= points.length || nextPointIndex < 0) {\n          // reached the minimum or maximum available point, can't push anymore\n          return false;\n        }\n\n        var nextHandle = handle + direction;\n        var nextValue = points[nextPointIndex];\n        var pushable = this.props.pushable;\n        var threshold = Number(pushable);\n        var diffToNext = direction * (bounds[nextHandle] - nextValue);\n\n        if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n          // couldn't push next handle, so we won't push this one either\n          return false;\n        } // push the handle\n        // eslint-disable-next-line no-param-reassign\n\n\n        bounds[handle] = nextValue;\n        return true;\n      }\n    }, {\n      key: \"trimAlignValue\",\n      value: function trimAlignValue(value) {\n        var _this$state2 = this.state,\n            handle = _this$state2.handle,\n            bounds = _this$state2.bounds;\n        return _trimAlignValue({\n          value: value,\n          handle: handle,\n          bounds: bounds,\n          props: this.props\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this4 = this;\n\n        var _this$state3 = this.state,\n            handle = _this$state3.handle,\n            bounds = _this$state3.bounds;\n        var _this$props4 = this.props,\n            prefixCls = _this$props4.prefixCls,\n            vertical = _this$props4.vertical,\n            included = _this$props4.included,\n            disabled = _this$props4.disabled,\n            min = _this$props4.min,\n            max = _this$props4.max,\n            reverse = _this$props4.reverse,\n            handleGenerator = _this$props4.handle,\n            trackStyle = _this$props4.trackStyle,\n            handleStyle = _this$props4.handleStyle,\n            tabIndex = _this$props4.tabIndex,\n            ariaLabelGroupForHandles = _this$props4.ariaLabelGroupForHandles,\n            ariaLabelledByGroupForHandles = _this$props4.ariaLabelledByGroupForHandles,\n            ariaValueTextFormatterGroupForHandles = _this$props4.ariaValueTextFormatterGroupForHandles;\n        var offsets = bounds.map(function (v) {\n          return _this4.calcOffset(v);\n        });\n        var handleClassName = \"\".concat(prefixCls, \"-handle\");\n        var handles = bounds.map(function (v, i) {\n          var _classNames;\n\n          var mergedTabIndex = tabIndex[i] || 0;\n\n          if (disabled || tabIndex[i] === null) {\n            mergedTabIndex = null;\n          }\n\n          var dragging = handle === i;\n          return handleGenerator({\n            className: classNames((_classNames = {}, _defineProperty(_classNames, handleClassName, true), _defineProperty(_classNames, \"\".concat(handleClassName, \"-\").concat(i + 1), true), _defineProperty(_classNames, \"\".concat(handleClassName, \"-dragging\"), dragging), _classNames)),\n            prefixCls: prefixCls,\n            vertical: vertical,\n            dragging: dragging,\n            offset: offsets[i],\n            value: v,\n            index: i,\n            tabIndex: mergedTabIndex,\n            min: min,\n            max: max,\n            reverse: reverse,\n            disabled: disabled,\n            style: handleStyle[i],\n            ref: function ref(h) {\n              return _this4.saveHandle(i, h);\n            },\n            ariaLabel: ariaLabelGroupForHandles[i],\n            ariaLabelledBy: ariaLabelledByGroupForHandles[i],\n            ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i]\n          });\n        });\n        var tracks = bounds.slice(0, -1).map(function (_, index) {\n          var _classNames2;\n\n          var i = index + 1;\n          var trackClassName = classNames((_classNames2 = {}, _defineProperty(_classNames2, \"\".concat(prefixCls, \"-track\"), true), _defineProperty(_classNames2, \"\".concat(prefixCls, \"-track-\").concat(i), true), _classNames2));\n          return React.createElement(Track, {\n            className: trackClassName,\n            vertical: vertical,\n            reverse: reverse,\n            included: included,\n            offset: offsets[i - 1],\n            length: offsets[i] - offsets[i - 1],\n            style: trackStyle[index],\n            key: i\n          });\n        });\n        return {\n          tracks: tracks,\n          handles: handles\n        };\n      }\n    }], [{\n      key: \"getDerivedStateFromProps\",\n      value: function getDerivedStateFromProps(props, state) {\n        if ('value' in props || 'min' in props || 'max' in props) {\n          var value = props.value || state.bounds;\n          var nextBounds = value.map(function (v, i) {\n            return _trimAlignValue({\n              value: v,\n              handle: i,\n              bounds: state.bounds,\n              props: props\n            });\n          });\n\n          if (nextBounds.length === state.bounds.length && nextBounds.every(function (v, i) {\n            return v === state.bounds[i];\n          })) {\n            return null;\n          }\n\n          return _objectSpread(_objectSpread({}, state), {}, {\n            bounds: nextBounds\n          });\n        }\n\n        return null;\n      }\n    }]);\n\n    return Range;\n  }(React.Component);\n  /* eslint-enable */\n\n\n  Range.displayName = 'Range';\n  Range.defaultProps = {\n    count: 1,\n    allowCross: true,\n    pushable: false,\n    tabIndex: [],\n    ariaLabelGroupForHandles: [],\n    ariaLabelledByGroupForHandles: [],\n    ariaValueTextFormatterGroupForHandles: []\n  };\n  return Range;\n}();\n\nexport default createSlider(Range);","map":{"version":3,"sources":["C:/Users/wODe/Desktop/School WIE19/Reactkurs/Checkout/checkout-reactjs/node_modules/rc-slider/es/Range.js"],"names":["_defineProperty","_toConsumableArray","_classCallCheck","_createClass","_inherits","_possibleConstructorReturn","_getPrototypeOf","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","sham","Proxy","Date","prototype","toString","call","e","React","classNames","shallowEqual","Track","createSlider","utils","_trimAlignValue","trimAlignValue","_ref","value","handle","bounds","props","allowCross","pushable","thershold","Number","valInRange","ensureValueInRange","valNotConflict","undefined","ensureValuePrecision","Range","_React$Component","_super","_this","onEnd","force","state","removeDocumentEvents","onAfterChange","getValue","setState","count","min","max","initialValue","Array","map","defaultValue","v","recent","calcValueByPos","calcOffset","saveHandle","index","h","componentDidUpdate","prevProps","prevState","_this2","_this$props","onChange","currentValue","some","isValueOutOfRange","newValues","isNotControlled","controlledState","item","data","changedValue","onStart","position","onBeforeChange","startValue","startPosition","closestBound","getClosestBound","prevMovedHandleIndex","getBoundNeedMoving","prevValue","nextBounds","onMove","pauseEvent","oldValue","moveTo","onKeyboard","_this$props2","reverse","vertical","valueMutator","getKeyboardValueMutator","mutatedValue","isFromKeyboardEvent","Math","abs","_this$state","boundNeedMoving","isAtTheSamePoint","getLowerBound","getUpperBound","getPoints","_this$props3","marks","step","cache","internalPointsCache","pointsObject","point","points","parseFloat","sort","a","b","_this3","nextHandle","pushSurroundingHandles","indexOf","handlesRefs","focus","threshold","direction","diffToNext","pushHandle","amount","originalValue","pushHandleOnePoint","pointIndex","nextPointIndex","nextValue","_this$state2","render","_this4","_this$state3","_this$props4","prefixCls","included","disabled","handleGenerator","trackStyle","handleStyle","tabIndex","ariaLabelGroupForHandles","ariaLabelledByGroupForHandles","ariaValueTextFormatterGroupForHandles","offsets","handleClassName","concat","handles","_classNames","mergedTabIndex","dragging","className","offset","style","ref","ariaLabel","ariaLabelledBy","ariaValueTextFormatter","tracks","slice","_","_classNames2","trackClassName","createElement","getDerivedStateFromProps","every","Component","displayName","defaultProps"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport classNames from 'classnames';\nimport shallowEqual from 'shallowequal';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\n\nvar _trimAlignValue = function trimAlignValue(_ref) {\n  var value = _ref.value,\n      handle = _ref.handle,\n      bounds = _ref.bounds,\n      props = _ref.props;\n  var allowCross = props.allowCross,\n      pushable = props.pushable;\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\n\nvar Range =\n/** @class */\nfunction () {\n  var Range = /*#__PURE__*/function (_React$Component) {\n    _inherits(Range, _React$Component);\n\n    var _super = _createSuper(Range);\n\n    function Range(props) {\n      var _this;\n\n      _classCallCheck(this, Range);\n\n      _this = _super.call(this, props);\n\n      _this.onEnd = function (force) {\n        var handle = _this.state.handle;\n\n        _this.removeDocumentEvents();\n\n        if (handle !== null || force) {\n          _this.props.onAfterChange(_this.getValue());\n        }\n\n        _this.setState({\n          handle: null\n        });\n      };\n\n      var count = props.count,\n          min = props.min,\n          max = props.max;\n      var initialValue = Array.apply(void 0, _toConsumableArray(Array(count + 1))).map(function () {\n        return min;\n      });\n      var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;\n      var value = props.value !== undefined ? props.value : defaultValue;\n      var bounds = value.map(function (v, i) {\n        return _trimAlignValue({\n          value: v,\n          handle: i,\n          props: props\n        });\n      });\n      var recent = bounds[0] === max ? 0 : bounds.length - 1;\n      _this.state = {\n        handle: null,\n        recent: recent,\n        bounds: bounds\n      };\n      return _this;\n    }\n    /**\n     * [Legacy] Used for inherit other component.\n     * It's a bad code style which should be refactor.\n     */\n\n    /* eslint-disable @typescript-eslint/no-unused-vars, class-methods-use-this */\n\n\n    _createClass(Range, [{\n      key: \"calcValueByPos\",\n      value: function calcValueByPos(value) {\n        return 0;\n      }\n    }, {\n      key: \"calcOffset\",\n      value: function calcOffset(value) {\n        return 0;\n      }\n    }, {\n      key: \"saveHandle\",\n      value: function saveHandle(index, h) {}\n    }, {\n      key: \"removeDocumentEvents\",\n      value: function removeDocumentEvents() {}\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps, prevState) {\n        var _this2 = this;\n\n        if (!('value' in this.props || 'min' in this.props || 'max' in this.props)) {\n          return;\n        }\n\n        if (this.props.min === prevProps.min && this.props.max === prevProps.max && shallowEqual(this.props.value, prevProps.value)) {\n          return;\n        }\n\n        var _this$props = this.props,\n            onChange = _this$props.onChange,\n            value = _this$props.value;\n        var currentValue = value || prevState.bounds;\n\n        if (currentValue.some(function (v) {\n          return utils.isValueOutOfRange(v, _this2.props);\n        })) {\n          var newValues = currentValue.map(function (v) {\n            return utils.ensureValueInRange(v, _this2.props);\n          });\n          onChange(newValues);\n        }\n      }\n    }, {\n      key: \"onChange\",\n      value: function onChange(state) {\n        var props = this.props;\n        var isNotControlled = !('value' in props);\n\n        if (isNotControlled) {\n          this.setState(state);\n        } else {\n          var controlledState = {};\n          ['handle', 'recent'].forEach(function (item) {\n            if (state[item] !== undefined) {\n              controlledState[item] = state[item];\n            }\n          });\n\n          if (Object.keys(controlledState).length) {\n            this.setState(controlledState);\n          }\n        }\n\n        var data = _objectSpread(_objectSpread({}, this.state), state);\n\n        var changedValue = data.bounds;\n        props.onChange(changedValue);\n      }\n    }, {\n      key: \"onStart\",\n      value: function onStart(position) {\n        var props = this.props,\n            state = this.state;\n        var bounds = this.getValue();\n        props.onBeforeChange(bounds);\n        var value = this.calcValueByPos(position);\n        this.startValue = value;\n        this.startPosition = position;\n        var closestBound = this.getClosestBound(value);\n        this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n        this.setState({\n          handle: this.prevMovedHandleIndex,\n          recent: this.prevMovedHandleIndex\n        });\n        var prevValue = bounds[this.prevMovedHandleIndex];\n        if (value === prevValue) return;\n\n        var nextBounds = _toConsumableArray(state.bounds);\n\n        nextBounds[this.prevMovedHandleIndex] = value;\n        this.onChange({\n          bounds: nextBounds\n        });\n      }\n    }, {\n      key: \"onMove\",\n      value: function onMove(e, position) {\n        utils.pauseEvent(e);\n        var state = this.state;\n        var value = this.calcValueByPos(position);\n        var oldValue = state.bounds[state.handle];\n        if (value === oldValue) return;\n        this.moveTo(value);\n      }\n    }, {\n      key: \"onKeyboard\",\n      value: function onKeyboard(e) {\n        var _this$props2 = this.props,\n            reverse = _this$props2.reverse,\n            vertical = _this$props2.vertical;\n        var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n\n        if (valueMutator) {\n          utils.pauseEvent(e);\n          var state = this.state,\n              props = this.props;\n          var bounds = state.bounds,\n              handle = state.handle;\n          var oldValue = bounds[handle === null ? state.recent : handle];\n          var mutatedValue = valueMutator(oldValue, props);\n\n          var value = _trimAlignValue({\n            value: mutatedValue,\n            handle: handle,\n            bounds: state.bounds,\n            props: props\n          });\n\n          if (value === oldValue) return;\n          var isFromKeyboardEvent = true;\n          this.moveTo(value, isFromKeyboardEvent);\n        }\n      }\n    }, {\n      key: \"getValue\",\n      value: function getValue() {\n        return this.state.bounds;\n      }\n    }, {\n      key: \"getClosestBound\",\n      value: function getClosestBound(value) {\n        var bounds = this.state.bounds;\n        var closestBound = 0;\n\n        for (var i = 1; i < bounds.length - 1; i += 1) {\n          if (value >= bounds[i]) {\n            closestBound = i;\n          }\n        }\n\n        if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n          closestBound += 1;\n        }\n\n        return closestBound;\n      }\n    }, {\n      key: \"getBoundNeedMoving\",\n      value: function getBoundNeedMoving(value, closestBound) {\n        var _this$state = this.state,\n            bounds = _this$state.bounds,\n            recent = _this$state.recent;\n        var boundNeedMoving = closestBound;\n        var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n\n        if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n          boundNeedMoving = recent;\n        }\n\n        if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n          boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n        }\n\n        return boundNeedMoving;\n      }\n    }, {\n      key: \"getLowerBound\",\n      value: function getLowerBound() {\n        return this.state.bounds[0];\n      }\n    }, {\n      key: \"getUpperBound\",\n      value: function getUpperBound() {\n        var bounds = this.state.bounds;\n        return bounds[bounds.length - 1];\n      }\n      /**\n       * Returns an array of possible slider points, taking into account both\n       * `marks` and `step`. The result is cached.\n       */\n\n    }, {\n      key: \"getPoints\",\n      value: function getPoints() {\n        var _this$props3 = this.props,\n            marks = _this$props3.marks,\n            step = _this$props3.step,\n            min = _this$props3.min,\n            max = _this$props3.max;\n        var cache = this.internalPointsCache;\n\n        if (!cache || cache.marks !== marks || cache.step !== step) {\n          var pointsObject = _objectSpread({}, marks);\n\n          if (step !== null) {\n            for (var point = min; point <= max; point += step) {\n              pointsObject[point] = point;\n            }\n          }\n\n          var points = Object.keys(pointsObject).map(parseFloat);\n          points.sort(function (a, b) {\n            return a - b;\n          });\n          this.internalPointsCache = {\n            marks: marks,\n            step: step,\n            points: points\n          };\n        }\n\n        return this.internalPointsCache.points;\n      }\n    }, {\n      key: \"moveTo\",\n      value: function moveTo(value, isFromKeyboardEvent) {\n        var _this3 = this;\n\n        var state = this.state,\n            props = this.props;\n\n        var nextBounds = _toConsumableArray(state.bounds);\n\n        var handle = state.handle === null ? state.recent : state.handle;\n        nextBounds[handle] = value;\n        var nextHandle = handle;\n\n        if (props.pushable !== false) {\n          this.pushSurroundingHandles(nextBounds, nextHandle);\n        } else if (props.allowCross) {\n          nextBounds.sort(function (a, b) {\n            return a - b;\n          });\n          nextHandle = nextBounds.indexOf(value);\n        }\n\n        this.onChange({\n          recent: nextHandle,\n          handle: nextHandle,\n          bounds: nextBounds\n        });\n\n        if (isFromKeyboardEvent) {\n          // known problem: because setState is async,\n          // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n          // cause onBeforeChange and onAfterChange receive wrong value.\n          // here use setState callback to hack，but not elegant\n          this.props.onAfterChange(nextBounds);\n          this.setState({}, function () {\n            _this3.handlesRefs[nextHandle].focus();\n          });\n          this.onEnd();\n        }\n      }\n    }, {\n      key: \"pushSurroundingHandles\",\n      value: function pushSurroundingHandles(bounds, handle) {\n        var value = bounds[handle];\n        var pushable = this.props.pushable;\n        var threshold = Number(pushable);\n        var direction = 0;\n\n        if (bounds[handle + 1] - value < threshold) {\n          direction = +1; // push to right\n        }\n\n        if (value - bounds[handle - 1] < threshold) {\n          direction = -1; // push to left\n        }\n\n        if (direction === 0) {\n          return;\n        }\n\n        var nextHandle = handle + direction;\n        var diffToNext = direction * (bounds[nextHandle] - value);\n\n        if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n          // revert to original value if pushing is impossible\n          // eslint-disable-next-line no-param-reassign\n          bounds[handle] = bounds[nextHandle] - direction * threshold;\n        }\n      }\n    }, {\n      key: \"pushHandle\",\n      value: function pushHandle(bounds, handle, direction, amount) {\n        var originalValue = bounds[handle];\n        var currentValue = bounds[handle];\n\n        while (direction * (currentValue - originalValue) < amount) {\n          if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n            // can't push handle enough to create the needed `amount` gap, so we\n            // revert its position to the original value\n            // eslint-disable-next-line no-param-reassign\n            bounds[handle] = originalValue;\n            return false;\n          }\n\n          currentValue = bounds[handle];\n        } // the handle was pushed enough to create the needed `amount` gap\n\n\n        return true;\n      }\n    }, {\n      key: \"pushHandleOnePoint\",\n      value: function pushHandleOnePoint(bounds, handle, direction) {\n        var points = this.getPoints();\n        var pointIndex = points.indexOf(bounds[handle]);\n        var nextPointIndex = pointIndex + direction;\n\n        if (nextPointIndex >= points.length || nextPointIndex < 0) {\n          // reached the minimum or maximum available point, can't push anymore\n          return false;\n        }\n\n        var nextHandle = handle + direction;\n        var nextValue = points[nextPointIndex];\n        var pushable = this.props.pushable;\n        var threshold = Number(pushable);\n        var diffToNext = direction * (bounds[nextHandle] - nextValue);\n\n        if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n          // couldn't push next handle, so we won't push this one either\n          return false;\n        } // push the handle\n        // eslint-disable-next-line no-param-reassign\n\n\n        bounds[handle] = nextValue;\n        return true;\n      }\n    }, {\n      key: \"trimAlignValue\",\n      value: function trimAlignValue(value) {\n        var _this$state2 = this.state,\n            handle = _this$state2.handle,\n            bounds = _this$state2.bounds;\n        return _trimAlignValue({\n          value: value,\n          handle: handle,\n          bounds: bounds,\n          props: this.props\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this4 = this;\n\n        var _this$state3 = this.state,\n            handle = _this$state3.handle,\n            bounds = _this$state3.bounds;\n        var _this$props4 = this.props,\n            prefixCls = _this$props4.prefixCls,\n            vertical = _this$props4.vertical,\n            included = _this$props4.included,\n            disabled = _this$props4.disabled,\n            min = _this$props4.min,\n            max = _this$props4.max,\n            reverse = _this$props4.reverse,\n            handleGenerator = _this$props4.handle,\n            trackStyle = _this$props4.trackStyle,\n            handleStyle = _this$props4.handleStyle,\n            tabIndex = _this$props4.tabIndex,\n            ariaLabelGroupForHandles = _this$props4.ariaLabelGroupForHandles,\n            ariaLabelledByGroupForHandles = _this$props4.ariaLabelledByGroupForHandles,\n            ariaValueTextFormatterGroupForHandles = _this$props4.ariaValueTextFormatterGroupForHandles;\n        var offsets = bounds.map(function (v) {\n          return _this4.calcOffset(v);\n        });\n        var handleClassName = \"\".concat(prefixCls, \"-handle\");\n        var handles = bounds.map(function (v, i) {\n          var _classNames;\n\n          var mergedTabIndex = tabIndex[i] || 0;\n\n          if (disabled || tabIndex[i] === null) {\n            mergedTabIndex = null;\n          }\n\n          var dragging = handle === i;\n          return handleGenerator({\n            className: classNames((_classNames = {}, _defineProperty(_classNames, handleClassName, true), _defineProperty(_classNames, \"\".concat(handleClassName, \"-\").concat(i + 1), true), _defineProperty(_classNames, \"\".concat(handleClassName, \"-dragging\"), dragging), _classNames)),\n            prefixCls: prefixCls,\n            vertical: vertical,\n            dragging: dragging,\n            offset: offsets[i],\n            value: v,\n            index: i,\n            tabIndex: mergedTabIndex,\n            min: min,\n            max: max,\n            reverse: reverse,\n            disabled: disabled,\n            style: handleStyle[i],\n            ref: function ref(h) {\n              return _this4.saveHandle(i, h);\n            },\n            ariaLabel: ariaLabelGroupForHandles[i],\n            ariaLabelledBy: ariaLabelledByGroupForHandles[i],\n            ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i]\n          });\n        });\n        var tracks = bounds.slice(0, -1).map(function (_, index) {\n          var _classNames2;\n\n          var i = index + 1;\n          var trackClassName = classNames((_classNames2 = {}, _defineProperty(_classNames2, \"\".concat(prefixCls, \"-track\"), true), _defineProperty(_classNames2, \"\".concat(prefixCls, \"-track-\").concat(i), true), _classNames2));\n          return React.createElement(Track, {\n            className: trackClassName,\n            vertical: vertical,\n            reverse: reverse,\n            included: included,\n            offset: offsets[i - 1],\n            length: offsets[i] - offsets[i - 1],\n            style: trackStyle[index],\n            key: i\n          });\n        });\n        return {\n          tracks: tracks,\n          handles: handles\n        };\n      }\n    }], [{\n      key: \"getDerivedStateFromProps\",\n      value: function getDerivedStateFromProps(props, state) {\n        if ('value' in props || 'min' in props || 'max' in props) {\n          var value = props.value || state.bounds;\n          var nextBounds = value.map(function (v, i) {\n            return _trimAlignValue({\n              value: v,\n              handle: i,\n              bounds: state.bounds,\n              props: props\n            });\n          });\n\n          if (nextBounds.length === state.bounds.length && nextBounds.every(function (v, i) {\n            return v === state.bounds[i];\n          })) {\n            return null;\n          }\n\n          return _objectSpread(_objectSpread({}, state), {}, {\n            bounds: nextBounds\n          });\n        }\n\n        return null;\n      }\n    }]);\n\n    return Range;\n  }(React.Component);\n  /* eslint-enable */\n\n\n  Range.displayName = 'Range';\n  Range.defaultProps = {\n    count: 1,\n    allowCross: true,\n    pushable: false,\n    tabIndex: [],\n    ariaLabelGroupForHandles: [],\n    ariaLabelledByGroupForHandles: [],\n    ariaValueTextFormatterGroupForHandles: []\n  };\n  return Range;\n}();\n\nexport default createSlider(Range);"]},"metadata":{},"sourceType":"module"}